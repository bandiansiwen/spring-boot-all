# 分支限界

### 什么是分支限界算法？

分支限界算法是一种在解空间树中搜索问题解的算法，它使用界限函数来剪去不可能产生最优解的分支，从而减少搜索空间。

### 分支限界算法的核心思想

1. 分支：将问题分解为子问题（扩展节点）
2. 限界：计算每个节点的界限值，剪去不可能达到最优解的分支
3. 搜索策略：使用优先队列选择最有希望的节点进行扩展

### 分支限界法通常有两种实现方式

1. 队列式（FIFO）分支限界法：使用队列存储活节点。
2. 优先队列式分支限界法：使用优先队列（通常用堆实现）存储活节点，每次选择优先级最高的节点进行扩展。

### 分支限界算法的关键要点

1. 界限函数：设计好的界限函数是算法效率的关键 
2. 剪枝策略：尽早剪去不可能产生最优解的分支 
3. 搜索策略：选择合适的节点扩展顺序（最佳优先） 
4. 存储管理：注意队列大小，避免内存溢出

### 界限函数设计技巧

1. 松弛法：放松问题的约束条件
2. 线性规划：用线性规划求上界 
3. 贪心法：用贪心算法求近似解作为界限 
4. 数学推导：通过数学分析得到界限

### 分支限界算法的优缺点

优点：

- 通常比回溯法更快找到最优解
- 可以处理大规模优化问题
- 保证找到最优解

缺点：

- 需要设计好的界限函数
- 最坏情况下可能退化为穷举搜索
- 需要存储活节点，可能占用大量内存

### 分支限界算法框架

```java
public class BranchAndBound {
    public Result solve(Problem problem) {
        // 初始化优先队列（按界限值排序）
        PriorityQueue<Node> queue = new PriorityQueue<>();
        queue.offer(new Node(problem));
        
        Result bestResult = null;
        
        while (!queue.isEmpty()) {
            Node current = queue.poll();
            
            // 如果当前节点不可能产生更好的解，剪枝
            if (current.bound <= bestResult.value) {
                continue;
            }
            
            // 如果当前节点是叶节点且比当前最优解好
            if (current.isLeaf() && current.value > bestResult.value) {
                bestResult = current.getResult();
                continue;
            }
            
            // 扩展子节点
            for (Node child : current.expand()) {
                if (child.bound > bestResult.value) {
                    queue.offer(child);
                }
            }
        }
        
        return bestResult;
    }
}
```

### 经典例子

经典问题——0-1背包问题来演示分支限界法的实现。

步骤：

1. 定义节点类，表示解空间树中的一个节点，包括当前重量、当前价值、当前物品索引、上界（用于优先队列排序）等。
2. 使用优先队列，按照上界从大到小排序（因为我们要最大化价值，所以上界大的节点优先级高）。
3. 计算上界函数：对于当前节点，剩余物品能够达到的最大价值（用贪心法，假设剩余物品可以按单位价值降序部分装入）。
4. 从根节点开始，依次扩展节点，直到队列为空。




























