# 回溯算法

### 回溯算法概述

回溯算法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该候选解，然后重新尝试。

回溯算法通常用递归来实现，它尝试分步去解决问题。在每一步，它都会尝试所有可能的选择，如果当前选择导致无法达到最终解，则撤销上一步或几步的选择，再尝试其他的选择。

### 核心思想

**"尝试-回退"** 的递归过程：

- 做出选择
- 递归探索
- 撤销选择（回溯）

### 回溯算法的关键要点

1. 路径：已经做出的选择 
2. 选择列表：当前可以做的选择 
3. 结束条件：到达决策树底层，无法再做选择的条件

### 回溯算法的适用场景

回溯算法通常用于解决以下类型的问题：

- 组合问题：从n个元素中找出k个元素的组合
- 排列问题：n个元素的全排列
- 子集问题：一个集合的所有子集
- 棋盘问题：N皇后，解数独等
- 分割问题：分割回文串，分割字符串等

### 回溯算法的解题步骤

1. 定义解空间：确定问题的解空间，包括解的形式（如数组、字符串等）和解的范围。
2. 确定约束条件：在扩展部分解时，需要满足的约束条件，用于剪枝。
3. 深度优先搜索：使用递归（或迭代）进行深度优先搜索，遍历解空间。
4. 回溯：当发现当前部分解不能达到最终解时，撤销上一步或几步的选择，然后继续搜索。

### 时间复杂度分析

回溯算法的时间复杂度通常是指数级的：

- 全排列：O(n!)
- 组合/子集：O(2^n)
- N皇后：O(n!)

### 优化技巧

1. 剪枝：提前排除不可能的解
2. 记忆化：存储已计算的状态
3. 约束条件：尽早判断是否满足条件

### 回溯算法的模板

下面是一个回溯算法的通用模板，你可以根据具体问题进行调整：

```java
public void backtrack(路径, 选择列表) {
    if (满足结束条件) {
        将路径添加到结果集;
        return;
    }

    for (选择 : 选择列表) {
        做选择;
        backtrack(路径, 选择列表);
        撤销选择;
    }
}
```

### 总结

回溯算法是一种强大的算法，可以解决很多组合优化问题。关键点在于：

- 理解问题，确定解空间和约束条件。
- 使用递归进行深度优先搜索，并在递归调用前后进行选择和撤销选择。
- 注意剪枝，避免不必要的计算。

LeetCode相关题目

1. 子集II（有重复元素） 
2. 全排列II（有重复数字） 
3. 组合总和II（每个数字只能使用一次） 
4. 单词搜索 
5. 分割回文串